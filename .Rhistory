v1 <- 1:10
v1
v2 <- 50:60
v2
v1*v2
vector(5)
vector(0)
character(5)
2 %% 5
5 %% 2
dotProduct <- function(vector1,
vector2,
cycle = F) {
# Returns the dot product of two vectors; the only difference between this
#       function and (vector1 * vector2) in R is the warning; this function will
#       throw an error if the vectors are of unequal lengths unless cycle = T.
if (length(vector1) != length(vector2)) {
if (cycle = F) {
stop("Vectors are of unequal lengths.")
} else {
if (length(vector1) > length(vector2)) {
longer <- vector1
shorter <- vector2
} else {
longer <- vector2
shorter <- vector1
}
}
} else {
longer <- vector1
shorter <- vector2
}
returnVector <- character(length(longer))
for (i in 1:length(longer)) {
returnVector[i] <- longer[i] * shorter[i %% length(shorter)]
}
returnVector
}
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
dotProduct <- function(vector1,
vector2,
cycle = F) {
# Returns the dot product of two vectors; the only difference between this
#       function and (vector1 * vector2) in R is the warning; this function will
#       throw an error if the vectors are of unequal lengths unless cycle = T.
if (length(vector1) != length(vector2)) {
if (cycle = F) {
stop("Vectors are of unequal lengths.")
} else {
if (length(vector1) > length(vector2)) {
longer <- vector1
shorter <- vector2
} else {
longer <- vector2
shorter <- vector1
}
}
} else {
longer <- vector1
shorter <- vector2
}
returnVector <- character(length(longer))
for (i in 1:length(longer)) {
returnVector[i] <- longer[i] * shorter[i %% length(shorter)]
}
returnVector
}
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
dotProduct <- function(vector1,
vector2,
cycle = F) {
# Returns the dot product of two vectors; the only difference between this
#       function and (vector1 * vector2) in R is the warning; this function will
#       throw an error if the vectors are of unequal lengths unless cycle = T.
if (length(vector1) != length(vector2)) {
if (cycle == F) {
stop("Vectors are of unequal lengths.")
} else {
if (length(vector1) > length(vector2)) {
longer <- vector1
shorter <- vector2
} else {
longer <- vector2
shorter <- vector1
}
}
} else {
longer <- vector1
shorter <- vector2
}
returnVector <- character(length(longer))
for (i in 1:length(longer)) {
returnVector[i] <- longer[i] * shorter[i %% length(shorter)]
}
returnVector
}
dotProduct(c(1,2),c(3,4))
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
dotProduct <- function(vector1,
vector2,
cycle = F) {
# Returns the dot product of two vectors; the only difference between this
#       function and (vector1 * vector2) in R is the warning; this function will
#       throw an error if the vectors are of unequal lengths unless cycle = T.
if (length(vector1) != length(vector2)) {
if (cycle == F) {
stop("Vectors are of unequal lengths.")
} else {
if (length(vector1) > length(vector2)) {
longer <- vector1
shorter <- vector2
} else {
longer <- vector2
shorter <- vector1
}
}
} else {
longer <- vector1
shorter <- vector2
}
print(longer)
print(shorter)
returnVector <- character(length(longer))
for (i in 1:length(longer)) {
returnVector[i] <- longer[i] * shorter[i %% length(shorter)]
}
returnVector
}
dotProduct(c(1,2),c(3,4))
c(1,2)[1]
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
dotProduct <- function(vector1,
vector2,
cycle = F) {
# Returns the dot product of two vectors; the only difference between this
#       function and (vector1 * vector2) in R is the warning; this function will
#       throw an error if the vectors are of unequal lengths unless cycle = T.
if (length(vector1) != length(vector2)) {
if (cycle == F) {
stop("Vectors are of unequal lengths.")
} else {
if (length(vector1) > length(vector2)) {
longer <- vector1
shorter <- vector2
} else {
longer <- vector2
shorter <- vector1
}
}
} else {
longer <- vector1
shorter <- vector2
}
returnVector <- character(length(longer))
for (i in 1:length(longer)) {
print(i %% length(shorter))
print(longer[i])
print(shorter[i %% length(shorter)])
returnVector[i] <- longer[i] * shorter[i %% length(shorter)]
}
returnVector
}
c(1,2)[1]
dotProduct(c(1,2),c(3,4))
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
dotProduct <- function(vector1,
vector2,
cycle = F) {
# Returns the dot product of two vectors; the only difference between this
#       function and (vector1 * vector2) in R is the warning; this function will
#       throw an error if the vectors are of unequal lengths unless cycle = T.
if (length(vector1) != length(vector2)) {
if (cycle == F) {
stop("Vectors are of unequal lengths.")
} else {
if (length(vector1) > length(vector2)) {
longer <- vector1
shorter <- vector2
} else {
longer <- vector2
shorter <- vector1
}
}
} else {
longer <- vector1
shorter <- vector2
}
returnVector <- character(length(longer))
for (i in 1:length(longer)) {
if (i %% length(shorter) == 0) {
shortIndex <- length(shorter)
} else {
shortIndex <- i %% length(shorter)
}
a <- longer[i]
b <- shorter[shortIndex]
print(shorter[i %% length(shorter)])
returnVector[i] <- a * b
}
returnVector
}
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
dotProduct <- function(vector1,
vector2,
cycle = F) {
# Returns the dot product of two vectors; the only difference between this
#       function and (vector1 * vector2) in R is the warning; this function will
#       throw an error if the vectors are of unequal lengths unless cycle = T.
if (length(vector1) != length(vector2)) {
if (cycle == F) {
stop("Vectors are of unequal lengths.")
} else {
if (length(vector1) > length(vector2)) {
longer <- vector1
shorter <- vector2
} else {
longer <- vector2
shorter <- vector1
}
}
} else {
longer <- vector1
shorter <- vector2
}
returnVector <- character(length(longer))
for (i in 1:length(longer)) {
if (i %% length(shorter) == 0) {
shortIndex <- length(shorter)
} else {
shortIndex <- i %% length(shorter)
}
a <- longer[i]
b <- shorter[shortIndex]
returnVector[i] <- a * b
}
returnVector
}
dotProduct(c(1,2),c(3,4))
c(1,2)*c(3,4)
Sys.time(c(1,2)*c(3,4))
ystem.time(c(1,2)*c(3,4))
system.time(c(1,2)*c(3,4))
system.time(c(1:10000)*c(10001:20000))
system.time(c(1:100000)*c(100001:200000))
system.time(c(1:10000)*c(10001:20000))
system.time(dotProduct(c(1:10000),c(10001:20000)))
system.time(dotProduct(c(1:10000),c(10001:20000),cycle=T))
system.time(dotProduct(c(1:10000),c(10001:20000),cycle=T))
system.time(dotProduct(c(1:10000),c(10001:2000),cycle=T))
system.time(dotProduct(c(1:10000),c(101:20000),cycle=T))
system.time(dotProduct(c(1:10000),c(101:20000),cycle=T))
system.time(dotProduct(c(1:10000),c(101:20000),cycle=T))
system.time(c(1:10000)*c(101:20000))
system.time(c(1:10000)*c(101:20000))
system.time(c(1:10000)*c(101:20000))
system.time(c(1:10000)*c(101:20000))
system.time(c(1:10000)*c(101:20000))
system.time(c(1:10000)*c(101:20000))
methods(sum)
showMethods(sum)
?sum
getMethod(sum)
getMethod(.Primitive("sum"))
.Primitive("sum")
debug(sum)
sum(1:4)
1:4[1]
1:4[FALSE]
1:4[FALSE][NA]
zzz
#       more familiar with their meanings.
getSum <- function(numbers) {
total <- 0
for (i in 1:length(numbers)) {
total <- total + numbers[i]
}
}
getSum(1)
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
getSum <- function(numbers) {
total <- 0
for (i in 1:length(numbers)) {
total <- total + numbers[i]
}
total
}
getSum(1)
getSum(1:5)
getSum(1:50)
getSum(1:500000)
system.time(getSum(1:500000))
system.time(getSum(1:500000))
system.time(getSum(1:500000))
system.time(getSum(1:500000))
system.time(sum(1:500000))
system.time(sum(1:5000))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
addNumber <- function(number) {
total <<- total + number
}
?apply
?lapply
total
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
getSum <- function(numbers) {
total <<- 0
lapply(numbers,addNumber)
total
}
addNumber <- function(number) {
total <<- total + number
}
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
# This file is filled with functions that are already present in base R or
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
getSum <- function(numbers) {
total <<- 0
sapply(numbers,addNumber)
total
}
addNumber <- function(number) {
total <<- total + number
}
dotProduct <- function(vector1,
vector2,
cycle = F) {
# Returns the dot product of two vectors; the only difference between this
#       function and (vector1 * vector2) in R is the warning; this function will
#       throw an error if the vectors are of unequal lengths unless cycle = T.
if (length(vector1) != length(vector2)) {
if (cycle == F) {
stop("Vectors are of unequal lengths.")
} else {
if (length(vector1) > length(vector2)) {
longer <- vector1
shorter <- vector2
} else {
longer <- vector2
shorter <- vector1
}
}
} else {
longer <- vector1
shorter <- vector2
}
returnVector <- character(length(longer))
for (i in 1:length(longer)) {
if (i %% length(shorter) == 0) {
shortIndex <- length(shorter)
} else {
shortIndex <- i %% length(shorter)
}
a <- longer[i]
b <- shorter[shortIndex]
returnVector[i] <- a * b
}
returnVector
}
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
system.time(sum(as.numeric(1:500000)))
getSum <- function(numbers) {
total <<- 0
addNumber <- function(number) {
total <<- total + number
}
sapply(numbers,addNumber)
total
}
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
getSum <- function(numbers) {
total <<- 0
addNumber <- function(number) {
total <<- total + number
}
lapply(numbers,addNumber)
total
}
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))$user
system.time(getSum(as.numeric(1:500000)))[1]
system.time(getSum(as.numeric(1:500000)))[1]
system.time(getSum(as.numeric(1:500000)))[1]
system.time(getSum(as.numeric(1:500000)))[1]
system.time(getSum(as.numeric(1:500000)))[1]
system.time(getSum(as.numeric(1:500000)))[1]
system.time(getSum(as.numeric(1:500000)))
getSum <- function(numbers) {
total <- 0
addNumber <- function(number) {
total <- total + number
}
lapply(numbers,addNumber)
total
}
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
getSum(as.numeric(1:500000))
#       extension libraries; however, I am replicating them in order to become
#       more familiar with their meanings.
getSum <- function(numbers) {
total <- 0
addNumber <- function(number) {
total <<- total + number
}
lapply(numbers,addNumber)
total
}
getSum(as.numeric(1:500000))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
system.time(getSum(as.numeric(1:500000)))
